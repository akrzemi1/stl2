%!TEX root = std.tex

\begin{addedblock}
\setcounter{chapter}{18}
\rSec0[concepts.lib]{Concepts library}

\ednote{This chapter is inserted between the chapters [language.support] and [diagnostics]. All
subsequence chapters should be renumbered as appropriate, but they aren't here for the sake of
simplicity).}

\rSec1[concepts.lib.general]{General}

\pnum
This Clause describes library components that \Cpp programs may use to perform
compile-time validation of template parameters and perform function dispatch
based on properties of types.

\pnum
The following subclauses describe core language concepts, foundational concepts,
function concepts, iterator concepts, and rearrangement concepts
as summarized in Table~\ref{tab:concepts.lib.summary}.

\begin{libsumtab}{Fundamental concepts library summary}{tab:concepts.lib.summary}
\ref{concepts.lib.corelang}       & Core language concepts  &   \tcode{<concepts>}      \\
\ref{concepts.lib.foundational}   & Foundational concepts   &                           \\
\ref{concepts.lib.functions}      & Function concepts       &                           \\
\end{libsumtab}

\pnum
In this Clause, \tcode{CamelCase} identifiers ending with ``\tcode{Type}'' denote
template aliases.

\pnum
A \techterm{regular function} is a function that returns equal output when passed
equal input. A regular function that returns a value may copy or move the returned
object, or may return a reference. Regular functions are allowed to have
side effects and preconditions that, when violated, make the function non-regular.
\enternote A function that returns \tcode{void} is necessarily a regular function.
\exitnote

\rSec1[concepts.lib.corelang]{Core language concepts}

\rSec2[concepts.lib.corelang.general]{In general}

\pnum
This section contains the definition of concepts corresponding to language features.
These concepts express relationships between types, type classifications, and
fundamental type properties.

\rSec2[concepts.lib.corelang.same]{Concept Same}

\indexlibrary{\idxcode{Same}}%
\begin{itemdecl}
template <class T, class U>
concept bool Same = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Same<T, U>} is an alias for \tcode{true} when \tcode{T} and \tcode{U}
denote the same type after the elimination of aliases; otherwise, it is an alias for
\tcode{false}.

\pnum
\remarks For the purposes of constraint checking, \tcode{Same<T, U>} implies
\tcode{Same<U, T>}.
\end{itemdescr}

\rSec2[concepts.lib.corelang.derived]{Concept Derived}

\indexlibrary{\idxcode{Derived}}%
\begin{itemdecl}
template <class T, class U>
concept bool Derived = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Derived<T, U>} has the same value as \tcode{is_base_of<U, T>::value}.
\end{itemdescr}

\rSec2[concepts.lib.corelang.convertible]{Concept Convertible}

\indexlibrary{\idxcode{Convertible}}%
\begin{itemdecl}
template <class T, class U>
concept bool Convertible = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Convertible<T, U>} has the same value as \tcode{is_convertible<T, U>::value}.
\end{itemdescr}

\rSec2[concepts.lib.corelang.common]{Concept Common}

\pnum
If \tcode{T} and \tcode{U} can both be explicitly converted to a third type,
\tcode{C}, then \tcode{T} and \tcode{U} share a \techterm{common type},
\tcode{C}. \enternote \tcode{C} could be the same as \tcode{T}, or \tcode{U}, or
it could be a different type.\exitnote This notion is encapsulated by the
\tcode{CommonType} alias and the \tcode{Common} concept.

\indexlibrary{\idxcode{Common}}%
\begin{itemdecl}
template <class T, class U>
using CommonType = common_type_t<T, U>;

template <class T, class U>
concept bool Common =
  requires (T t, U u) {
    typename CommonType<T, U>;
    typename CommonType<U, T>;
    requires Same<CommonType<U, T>, CommonType<T, U> >;
    CommonType<T, U>(forward<T>(t));
    CommonType<T, U>(forward<U>(u));
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
Two types \tcode{T} and \tcode{U} model the \tcode{Common} concept when the type
alias \tcode{CommonType<T, U>} is well-formed, and when objects of types \tcode{T}
and \tcode{U} can be explicitly converted to the common type.

\pnum
Let \tcode{C} be \tcode{CommonType<T, U>}. Let \tcode{t1} and \tcode{t2} be objects
of type \tcode{T}. \tcode{t1} equals \tcode{t2} if and only if
\tcode{C(t1)} equals
\tcode{C(t2)}. Let \tcode{u1} and \tcode{u2} be
object of type \tcode{U}. \tcode{u1} equals \tcode{u2} if and only if
\tcode{C(u1)} equals
\tcode{C(u2)}.

\pnum
\enternote Users are free to specialize \tcode{common_type} when at least one parameter is a
user-defined type. Those specializations are considered by the \tcode{Common} concept.\exitnote

\end{itemdescr}

\rSec2[concepts.lib.corelang.boolean]{Concept Boolean}

\indexlibrary{\idxcode{Boolean}}%
\begin{itemdecl}
template <class B>
concept bool Boolean =
  requires(B b1, B b2) {
    bool(b1);
    { b1 } -> bool;
    bool(!b1);
    { !b1 } -> bool;
    { b1 && b2 } -> Same<bool>;
    { b1 || b2 } -> Same<bool>;
  };
\end{itemdecl}

\pnum
The \tcode{Boolean} concept describes the requirements on a type that is usable in Boolean contexts.

\pnum
Given values \tcode{b1} and \tcode{b2} of type \tcode{B}, then type \tcode{B} models
\tcode{Boolean} if and only if

\begin{itemize}
\item \tcode{bool(b1) == [](bool x) \{ return x; \}(b1)}.
\item \tcode{bool(b1) == !bool(!b1)}.
\item \tcode{(b1 \&\& b2)}, \tcode{(b1 \&\& bool(b2))}, and
      \tcode{(bool(b1) \&\& b2)} are all semantically identical to
      \tcode{(bool(b1) \&\& bool(b2))}, including short-circuit evaluation.
\item \tcode{(b1 || b2)}, \tcode{(b1 || bool(b2))}, and
      \tcode{(bool(b1) || b2)} are all semantically identical to
      \tcode{(bool(b1) || bool(b2))}, including short-circuit evaluation.
\end{itemize}

\enterexample The types \tcode{bool}, \tcode{std::true_type}, and
\tcode{std::bitset<>::reference} are \tcode{Boolean} types.\exitexample

\rSec2[concepts.lib.corelang.integral]{Concept Integral}

\indexlibrary{\idxcode{Integral}}%
\begin{itemdecl}
template <class T>
concept bool Integral = is_integral<T>::value;
\end{itemdecl}

\rSec2[concepts.lib.corelang.signedintegral]{Concept SignedIntegral}

\indexlibrary{\idxcode{SignedIntegral}}%
\begin{itemdecl}
template <class T>
concept bool SignedIntegral =
  Integral<T> && is_signed<T>::value;
\end{itemdecl}

\begin{itemdescr}
\pnum
\enternote \tcode{SignedIntegral<T>} may be true even for types that are not signed
integral types~(\cxxref{basic.fundamental}).
\exitnote
\end{itemdescr}

\rSec2[concepts.lib.corelang.unsignedintegral]{Concept UnsignedIntegral}

\indexlibrary{\idxcode{UnsignedIntegral}}%
\begin{itemdecl}
template <class T>
concept bool UnsignedIntegral =
  Integral<T> && !SignedIntegral<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\enternote \tcode{UnsignedIntegral<T>} may be true even for types that are not unsigned
integral types~(\cxxref{basic.fundamental}).
\exitnote
\end{itemdescr}

\rSec2[concepts.lib.corelang.defaultconstructible]{Concept DefaultConstructible}

\ednote{Remove table [defaultconstructible] in [utility.arg.requirements]. Replace
references to [defaultconstructible] with references to
[concepts.lib.corelang.defaultconstructible].}

\indexlibrary{\idxcode{DefaultConstructible}}%
\begin{itemdecl}
template <class T>
concept bool DefaultConstructible =
  requires {
    T{};
  };
\end{itemdecl}

\begin{itemdescr}
\ednote{REVIEW: The C++14 \tcode{DefaultConstructible} requirements table also requires \tcode{T()} as
a valid expression, but that disallows array types. However, \tcode{is_default_constructible<int[4]>::value}
is true. It's not clear to me whether the requirements table is wrong or whether the exclusion of
array types was intentional.}
\end{itemdescr}

\rSec2[concepts.lib.corelang.moveconstructible]{Concept MoveConstructible}
\ednote{Remove table [moveconstructible] in [utility.arg.requirements]. Replace
references to [moveconstructible] with references to
[concepts.lib.corelang.moveconstructible].}

\indexlibrary{\idxcode{MoveConstructible}}%
\begin{itemdecl}
template <class T>
concept bool MoveConstructible =
  requires (T t) {
    T(move(t));
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{rv} be an rvalue of type \tcode{T}. Then a type \tcode{T} models
\tcode{MoveConstructible} if and only if

\begin{itemize}
\item After the definition \tcode{T u = rv;}, \tcode{u} is equal to the value of
\tcode{rv} before the construction.
\item \tcode{T(rv)} is equal to the value of \tcode{rv} before the construction.
\end{itemize}

\pnum
\tcode{rv}'s state is unspecified. \enternote \tcode{rv} must still meet the
requirements of the library component that is using it. The operations listed
in those requirements must work as specified whether \tcode{rv} has been moved
from or not.\exitnote
\end{itemdescr}

\rSec2[concepts.lib.corelang.copyconstructible]{Concept CopyConstructible}
\ednote{Remove table [copyconstructible] in [utility.arg.requirements]. Replace
references to [copyconstructible] with references to
[concepts.lib.corelang.copyconstructible].}

\indexlibrary{\idxcode{CopyConstructible}}%
\begin{itemdecl}
template <class T>
concept bool CopyConstructible =
  MoveConstructible<T> && 
  requires (T a, const T& b) {
    T(a);
    T(b);
    T((const T&&)b);
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{v} be an lvalue of type (possibly \tcode{const}) \tcode{T} or an rvalue
of type \tcode{const T}. Then a type \tcode{T} models \tcode{CopyConstructible} if
and only if

\begin{itemize}
\item After the definition \tcode{T u = v;}, \tcode{v} is unchanged and is equal
to \tcode{u}.
\item \tcode{T(v)} is equal to \tcode{v} and \tcode{v} is unchanged.
\end{itemize}
\end{itemdescr}

\rSec2[concepts.lib.corelang.constructible]{Concept Constructible}

\indexlibrary{\idxcode{Constructible}}%
\begin{itemdecl}
template <class T, class ...Args>
concept bool Constructible =
  requires ( Args...args ) {
    T{forward<Args>(args)...};
  };
\end{itemdecl}

\rSec2[concepts.lib.corelang.destructible]{Concept Destructible}
\ednote{Remove table [destructible] in [utility.arg.requirements]. Replace
references to [destructible] with references to
[concepts.lib.corelang.destructible].}

\indexlibrary{\idxcode{Destructible}}%
\begin{itemdecl}
template <class T>
concept bool Destructible =
  requires (T t) {
    { t.$\sim$T() } noexcept;
  };
\end{itemdecl}

\begin{itemdescr}
\ednote{REVIEW: The expression \tcode{t.$\sim$T()} comes straight from the requirements table for the
\tcode{Destructible} concept in C++14. However, \tcode{t.$\sim$T()} is not valid if \tcode{T} is a
reference or array type. We need to decide whether we want \tcode{Destructible<int\&>} and
\tcode{Destructible<int[42]>} to be true or false.}

\pnum
A type \tcode{T} models \tcode{Destructible} if and only if

\begin{itemize}
\item After the expression \tcode{u.$\sim$T()}, all resources owned by \tcode{u} are
reclaimed.
\end{itemize}
\end{itemdescr}

\rSec2[concepts.lib.corelang.moveassignable]{Concept MoveAssignable}
\ednote{Remove table [moveassignable] in [utility.arg.requirements]. Replace
references to [moveassignable] with references to
[concepts.lib.corelang.moveassignable].}

\indexlibrary{\idxcode{MoveAssignable}}%
\begin{itemdecl}
template <class T>
concept bool MoveAssignable =
  requires(T a, T b) {
    { a = move(b) } -> Same<T&>;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{rv} be an rvalue of type \tcode{T}
and let \tcode{t} be an lvalue of type \tcode{T}. Then type \tcode{T} models
\tcode{MoveAssignable} if and only if

\begin{itemize}
\item \tcode{(addressof(t = rv) == addressof(t)) != false)}.
\item After the assignment \tcode{t} is equal to the value
of \tcode{rv} before the assignment.
\end{itemize}

\pnum
\tcode{rv}'s state is unspecified. \enternote \tcode{rv} must still meet the
requirements of the library component that is using it. The operations listed
in those requirements must work as specified whether \tcode{rv} has been moved
from or not.\exitnote
\end{itemdescr}

\rSec2[concepts.lib.corelang.copyassignable]{Concept CopyAssignable}
\ednote{Remove table [copyassignable] in [utility.arg.requirements]. Replace
references to [copyassignable] with references to
[concepts.lib.corelang.copyassignable].}

\indexlibrary{\idxcode{CopyAssignable}}%
\begin{itemdecl}
template <class T>
concept bool CopyAssignable =
  MoveAssignable<T> && 
  requires(T a, T b, const T& c) {
    { a = b } -> Same<T&>;
    { a = c } -> Same<T&>;
    { a = (const T&&)c } -> Same<T&>;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{t} be an lvalue of type \tcode{T}, and \tcode{v} be an lvalue of type (possibly
\tcode{const}) \tcode{T} or an rvalue of type \tcode{const T}. Then type \tcode{T} models
\tcode{CopyAssignable} if and only if

\begin{itemize}
\item \tcode{(addressof(t = v) == addressof(t)) != false)}.
\item After the assignment \tcode{t} is equal to \tcode{v} and \tcode{v} is unchanged.
\end{itemize}
\end{itemdescr}

\rSec2[concepts.lib.corelang.assignable]{Concept Assignable}

\indexlibrary{\idxcode{Assignable}}%
\begin{itemdecl}
template <class T, class U = T>
concept bool Assignable =
  requires(T a, U b) {
    { a = forward<U>(b) } -> Same<T&>;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{t} be an lvalue of type \tcode{T}. If \tcode{U} is a reference type, let \tcode{v}
be a lvalue of type \tcode{U}; otherwise, let \tcode{v} be an rvalue of type \tcode{U}.
Then types \tcode{T} and \tcode{U} model \tcode{Assignable} if and only if

\begin{itemize}
\item \tcode{(addressof(t = v) == addressof(t)) != false)}.
\end{itemize}
\end{itemdescr}

\rSec2[concepts.lib.corelang.swappable]{Concept Swappable}
\ednote{Remove subclause [swappable.requirements]. Replace references to
[swappable.requirements] with [concepts.lib.corelang.swappable].}

\indexlibrary{\idxcode{Swappable}}%
\begin{itemdecl}
template <class T>
concept bool Swappable() {
  return requires(T t, T u) {
    swap(forward<T>(t), forward<T>(u));
  };
}

template <class T, class U>
concept bool Swappable() {
  return Swappable<T>() &&
    Swappable<U>() &&
    Common<T, U> &&
    requires(T t, U u) {
      swap(forward<T>(t), forward<U>(u));
      swap(forward<U>(u), forward<T>(t));
    };
}
end{itemdecl}

\begin{itemdescr}
\ednote{The following is copied almost verbatim from [swappable.requirements]}

\pnum
This subclause provides definitions for swappable types and expressions. In these
definitions, let \tcode{t} denote an expression of type \tcode{T}, and let \tcode{u}
denote an expression of type \tcode{U}.

\pnum
An object \tcode{t} is \defn{swappable with} an object \tcode{u} if and only if
types \tcode{T} and \tcode{U} model \tcode{Swappable}. Types \tcode{T} and \tcode{U}
model \tcode{Swappable} if and only if:

\begin{itemize}
\item the requires clause above is evaluated in the context described below, and

\item these expressions have the following effects:

\begin{itemize}
\item the object referred to by \tcode{t} has the value originally held by \tcode{u} and
\item the object referred to by \tcode{u} has the value originally held by \tcode{t}.
\end{itemize}
\end{itemize}

\pnum
The context in which the requires clause is evaluated shall
ensure that a binary non-member function named ``\tcode{swap}'' is selected via overload
resolution~(\cxxref{over.match}) on a candidate set that includes:

\begin{itemize}
\item the two \tcode{swap} function templates defined in
\tcode{<utility>}~(\ref{utility}) and

\item the lookup set produced by argument-dependent lookup~(\cxxref{basic.lookup.argdep}).
\end{itemize}

\enternote If \tcode{T} and \tcode{U} are both fundamental types or arrays of
fundamental types and the declarations from the header \tcode{<utility>} are in
scope, the overall lookup set described above is equivalent to that of the
qualified name lookup applied to the expression \tcode{std::swap(t, u)} or
\tcode{std::swap(u, t)} as appropriate. \exitnote

\enternote It is unspecified whether a library component that has a swappable
requirement includes the header \tcode{<utility>} to ensure an appropriate
evaluation context. \exitnote

\pnum
An rvalue or lvalue \tcode{t} is \defn{swappable} if and only if \tcode{t} is
swappable with any rvalue or lvalue, respectively, of type \tcode{T}.

\enterexample User code can ensure that the evaluation of \tcode{swap} calls
is performed in an appropriate context under the various conditions as follows:
\begin{codeblock}
#include <utility>

// Requires: \tcode{std::forward<T>(t)} shall be swappable with \tcode{std::forward<U>(u)}.
template <class T, class U>
void value_swap(T&& t, U&& u) {
  using std::swap;
  swap(std::forward<T>(t), std::forward<U>(u)); // OK: uses ``swappable with'' conditions
                                                // for rvalues and lvalues
}

// Requires: lvalues of \tcode{T} shall be swappable.
template <class T>
void lv_swap(T& t1, T& t2) {
  using std::swap;
  swap(t1, t2);                                 // OK: uses swappable conditions for
}                                               // lvalues of type \tcode{T}

namespace N {
  struct A { int m; };
  struct Proxy { A* a; };
  Proxy proxy(A& a) { return Proxy{ &a }; }

  void swap(A& x, Proxy p) {
    std::swap(x.m, p.a->m);                     // OK: uses context equivalent to swappable
                                                // conditions for fundamental types
  }
  void swap(Proxy p, A& x) { swap(x, p); }      // satisfy symmetry constraint
}

int main() {
  int i = 1, j = 2;
  lv_swap(i, j);
  assert(i == 2 && j == 1);

  N::A a1 = { 5 }, a2 = { -5 };
  value_swap(a1, proxy(a2));
  assert(a1.m == -5 && a2.m == 5);
}
\end{codeblock}
\exitexample
\end{itemdescr}

\rSec1[concepts.lib.foundational]{Foundational concepts}

\rSec2[concepts.lib.foundational.general]{In general}

\pnum
This section describes the foundational concepts that describe the basis of the value-oriented
programming style on which the library is based. The purpose of these concepts is to establish
a foundation for equational reasoning in programs.

\rSec2[concepts.lib.foundational.equalitycomparable]{Concept EqualityComparable}

\ednote{Remove table [equalitycomparable] in [utility.arg.requirements]. Replace references to
[equalitycomparable] with [concepts.lib.equalitycomparable].}

\indexlibrary{\idxcode{EqualityComparable}}%
\begin{itemdecl}
template <class T>
concept bool EqualityComparable() {
  return requires(T a, T b) {
    {a == b} -> Boolean;
    {a != b} -> Boolean;
  };
}
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{a}, \tcode{b}, and \tcode{c} be well-formed objects of type \tcode{T}. Then type
\tcode{T} models \tcode{EqualityComparable} if and only if

\begin{itemize}
\item \tcode{(a == a) != false}.
\item \tcode{(a == b) != false} if and only if \tcode{a} is equal to \tcode{b}.
\item \tcode{(a == b) != false} if and only if \tcode{(b == a) != false}.
\item \tcode{(a != b) != false} if and only if \tcode{(a == b) == false}.
\item \tcode{(a == b) != false \&\& (b == c) != false} if and only if \tcode{(a == c) != false}.
\end{itemize}

\pnum
\enternote Not all arguments will be well-formed for a given type. For example, $NaN$ is not a
well-formed floating point value, and many types' moved-from states are not well-formed. This
does not mean that the type does not model \tcode{EqualityComparable}.\exitnote
\end{itemdescr}

\begin{itemdecl}
template <class T, class U>
concept bool EqualityComparable() {
  return Common<T, U> &&
    EqualityComparable<T>() &&
    EqualityComparable<U>() &&
    EqualityComparable<CommonType<T, U>>() &&
    requires(T a, U b) {
      {a == b} -> Boolean;
      {b == a} -> Boolean;
      {a != b} -> Boolean;
      {b != a} -> Boolean;
    };
}
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{a} be an object of type \tcode{T}, \tcode{b} be an object of type \tcode{U}, and \tcode{C} be
\tcode{CommonType<T, U>}. Then types \tcode{T} and \tcode{U} model \tcode{EqualityComparable} if
and only if

\begin{itemize}
\item \tcode{(a == b) != false} if and only if \tcode{(C(a) == C(b)) != false}.
\item \tcode{(a != b) != false} if and only if \tcode{(C(a) != C(b)) != false}.
\item \tcode{(b == a) != false} if and only if \tcode{(C(b) == C(a)) != false}.
\item \tcode{(b != a) != false} if and only if \tcode{(C(b) != C(a)) != false}.
\end{itemize}
\end{itemdescr}

\ednote{BUGBUG There is concern on the committee that the \tcode{Common} requirement is
overconstraining here. (In \tcode{Relation} too.}

\rSec2[concepts.lib.foundational.semiregular]{Concept Semiregular}

\indexlibrary{\idxcode{Semiregular}}%
\begin{itemdecl}
template <class T>
concept bool Semiregular =
  DefaultConstructible<T> &&
  CopyConstructible<T> &&
  Destructible<T> &&
  CopyAssignable<T> &&
  requires(T a, size_t n, T* p) {
    // Object
    { &a } -> Same<T*>;
    // Destruction
    { a.~T() } noexcept;
    // Allocation
    { new T } -> Same<T*>;
    { new T[n] } -> Same<T*>;
    // Deallocation
    delete p;
    delete[] p;
  };
\end{itemdecl}

\ednote{The concepts are probably too fine-grained here. Look again at ``The Palo Alto''
report; in particular, at the definition of \tcode{Semiregular} in Appendix D.}

\begin{itemdescr}
\pnum
Let \tcode{a} be any well-formed object of type \tcode{T}. Then type \tcode{T} models
\tcode{Semiregular} if and only if

\begin{itemize}
\item \tcode{(\&a == addressof(a)) != false}.
\item \tcode{a} is not a volatile object or const volatile object~(\cxxref{basic.type.qualifier}).
\end{itemize}

\pnum
\enternote The \tcode{Semiregular} concept is modeled by types that have behave similarly to
built-in types like \tcode{int}, except that they may not be comparable with \tcode{==}.\exitnote
\end{itemdescr}

\rSec2[concepts.lib.foundational.regular]{Concept Regular}

\indexlibrary{\idxcode{Regular}}%
\begin{itemdecl}
template <class T>
concept bool Regular =
  Semiregular<T>() && EqualityComparable<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\enternote The \tcode{Regular} concept is modeled by types that behave similarly to
built-in types like \tcode{int} and that are comparable with \tcode{==}.\exitnote
\end{itemdescr}

\rSec2[concepts.lib.foundational.totallyordered]{Concept TotallyOrdered}

\ednote{Remove table [lessthancomparable] in [utility.arg.requirements]. Replace uses of
\tcode{LessThanComparable} with \tcode{TotallyOrdered} (acknowledging that this is a breaking
change that makes type requirements stricter). Replace references to [lessthancomparable] with
references to [concepts.lib.totallyordered]}

\indexlibrary{\idxcode{TotallyOrdered}}%
\begin{itemdecl}
template <class T>
concept bool TotallyOrdered() {
  return EqualityComparable<T>() &&
    requires (T a, T b) {
      { a < b } -> Boolean;
      { a > b } -> Boolean;
      { a <= b } -> Boolean;
      { a >= b } -> Boolean;
    };
}
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{a}, \tcode{b}, and \tcode{c} be well-formed objects of type \tcode{T}. Then type
\tcode{T} models \tcode{TotallyOrdered} if and only if

\begin{itemize}
\item \tcode{(a < a) == false}.
\item If \tcode{(a < b) != false}, then \tcode{(b < a) == false}.
\item If \tcode{(a < b) != false} and \tcode{(b < c) != false}, then
      \tcode{(a < c) != false}.
\item Exactly one of the following is true: \tcode{(a < b) != false}, or
      \tcode{(b < a) != false}, or \tcode{(a == b) != false}.
\item \tcode{(a > b) != false} if and only if \tcode{(b < a) != false}.
\item \tcode{(a <= b) != false} if and only if \tcode{(b < a) == false}.
\item \tcode{(a >= b) != false} if and only if \tcode{(b > a) == false}.
\end{itemize}

\pnum
\enternote Not all arguments will be well-formed for a given type. For example, $NaN$ is not a
well-formed floating point value, and many types' moved-from states are not well-formed. This
does not mean that the type does not model \tcode{TotallyOrdered}.\exitnote
\end{itemdescr}

\begin{itemdecl}
template <class T, class U>
concept bool TotallyOrdered() {
  return Common<T, U> &&
    TotallyOrdered<T>() &&
    TotallyOrdered<U>() &&
    TotallyOrdered<CommonType<T, U>>() &&
    EqualityComparable<T, U>() &&
    requires (T a, U b) {
      { a < b } -> Boolean;
      { a > b } -> Boolean;
      { a <= b } -> Boolean;
      { a >= b } -> Boolean;
      { b < a } -> Boolean;
      { b > a } -> Boolean;
      { b <= a } -> Boolean;
      { b >= a } -> Boolean;
    };
}
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{a} be an object of type T, \tcode{b} be an object of type \tcode{U}, and \tcode{C} be
\tcode{CommonType<T, U>}. Then types \tcode{T} and \tcode{U} model \tcode{EqualityComparable} if
and only if

\begin{itemize}
\item \tcode{(a < b) != false} if and only if \tcode{(C(a) < C(b)) != false}.
\item \tcode{(a > b) != false} if and only if \tcode{(C(a) > C(b)) != false}.
\item \tcode{(a <= b) != false} if and only if \tcode{(C(a) <= C(b)) != false}.
\item \tcode{(a >= b) != false} if and only if \tcode{(C(a) >= C(b)) != false}.
\item \tcode{(b < a) != false} if and only if \tcode{(C(b) < C(a)) != false}.
\item \tcode{(b > a) != false} if and only if \tcode{(C(b) > C(a)) != false}.
\item \tcode{(b <= a) != false} if and only if \tcode{(C(b) <= C(a)) != false}.
\item \tcode{(b >= a) != false} if and only if \tcode{(C(b) >= C(a)) != false}.
\end{itemize}
\end{itemdescr}

\rSec1[concepts.lib.functions]{Function concepts}

\rSec2[concepts.lib.functions.general]{In general}

\pnum
The function concepts in this section describe the requirements on function
objects~(\ref{function.objects}) and their arguments.

\rSec2[concepts.lib.functions.function]{Concept Function}

\indexlibrary{\idxcode{Function}}%
\begin{itemdecl}
template <class F, class...Args>
using ResultType = result_of_t<F(Args...)>;

template <class F, class...Args>
concept bool Function =
  Destructible<@\oldtxt{T}\newtxt{F}@> &&
  CopyConstructible<@\oldtxt{T}\newtxt{F}@> &&
  requires (F f, Args...args@\newtxt{, const F\& cf, F* fptr}@) {
    typename ResultType<F, Args...>;
    { &f } -> Same<F*>;
    @\oldtxt{\{ f.~F() \} noexcept;}@
    @\oldtxt{\{ }@new F@\newtxt{(cf)}\oldtxt{ \} -> Same<F*>}@;
    delete @\oldtxt{new F}\newtxt{fptr}@;
    { f(forward<Args>(args)...) } -> Same<ResultType<F, Args...>>;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{f} be any object of type \tcode{F}. Then types \tcode{F} and \tcode{Args...} model
\tcode{Function} if and only if

\begin{itemize}
\item \tcode{(\&f == addressof(f)) != false}.
\end{itemize}

\pnum
The function call expression need not be equality-preserving; that is, the expression
\tcode{f(args...)} is allowed to return non-equal objects when called with equal arguments,
and still model \tcode{Function}.

\pnum
\enternote Since models of \tcode{Function} are allowed to be non-equality-preserving, a
function that generates random numbers may model \tcode{Function}.\exitnote
\end{itemdescr}

\rSec2[concepts.lib.functions.regularfunction]{Concept RegularFunction}

\indexlibrary{\idxcode{RegularFunction}}%
\begin{itemdecl}
template <class F, class...Args>
concept bool RegularFunction =
  Function<F, Args...>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Models of \tcode{RegularFunction} shall be equality-preserving; that is, when passed
equal arguments, they shall return equal objects.

\pnum
\enternote A random number generator is not a model of \tcode{RegularFunction}.\exitnote

\pnum
\enternote There is no syntactic difference between \tcode{Function} and
\tcode{RegularFunction}.\exitnote
\end{itemdescr}

\rSec2[concepts.lib.functions.predicate]{Concept Predicate}

\indexlibrary{\idxcode{Predicate}}%
\begin{itemdecl}
template <class F, class...Args>
concept bool Predicate =
  RegularFunction<F, Args...> &&
  @\newtxt{Boolean}\oldtxt{Convertible}@<ResultType<F, Args...>@\oldtxt{, bool}@>;
\end{itemdecl}

\rSec2[concepts.lib.functions.relation]{Concept Relation}

\indexlibrary{\idxcode{Relation}}%
\begin{itemdecl}
template <class F, class T>
concept bool Relation() {
  return Predicate<F, T, T>;
}

template <class R, class T, class U>
concept bool Relation() {
  return Relation<R, T>() &&
    Relation<R, U>() &&
    Common<T, U> &&
    Relation<R, CommonType<T, U>>() &&
    @\newtxt{Predicate<R, T, U> \&\&}@
    @\newtxt{Predicate<R, U, T>;}@
    @\oldtxt{requires (R r, T a, U b) \{}@
      @\oldtxt{\{ r(a, b) \} -> Boolean;}@
      @\oldtxt{\{ r(b, a) \} -> Boolean;}@
    @\oldtxt{\};}@
}
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{r} be any well-formed object of type \tcode{R}, \tcode{a} be any well-formed object of
type \tcode{T}, \tcode{b} be any well-formed object of type \tcode{U}, and \tcode{C} be
\tcode{CommonType<T, U>}. Then types \tcode{R}, \tcode{T}, and \tcode{U} model \tcode{Relation} if
and only if

\begin{itemize}
\item \tcode{r(a, b) != false} if and only if \tcode{r(C(a), C(b)) != false}.
\item \tcode{r(b, a) != false} if and only if \tcode{r(C(b), C(a)) != false}.
\end{itemize}
\end{itemdescr}

\rSec2[concepts.lib.functions.strictweakorder]{Concept StrictWeakOrder}

\indexlibrary{\idxcode{Relation}}%
\begin{itemdecl}
template <class F, class T>
concept bool StrictWeakOrder() {
  return Relation<F, T>();
}

template <class R, class T, class U>
concept bool StrictWeakOrder() {
  return Relation<R, T, U>();
}
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{comp} be a well-formed object of type \tcode{Comp}. Then type \tcode{Comp} models concept
\tcode{StrictWeakOrder} if and only if it imposes a \techterm{strict weak ordering} on its arguments.

\ednote{Copied verbatim from [alg.sorting].}

{\color{black}
\pnum
The term
\techterm{strict}
refers to the
requirement of an irreflexive relation (\tcode{!comp(x, x)} for all \tcode{x}),
and the term
\techterm{weak}
to requirements that are not as strong as
those for a total ordering,
but stronger than those for a partial
ordering.
If we define
\tcode{equiv(a, b)}
as
\tcode{!comp(a, b) \&\& !comp(b, a)},
then the requirements are that
\tcode{comp}
and
\tcode{equiv}
both be transitive  relations:

\begin{itemize}
\item
\tcode{comp(a, b) \&\& comp(b, c)}
implies
\tcode{comp(a, c)}
\item
\tcode{equiv(a, b) \&\& equiv(b, c)}
implies
\tcode{equiv(a, c)}
\enternote
Under these conditions, it can be shown that
\begin{itemize}
\item
\tcode{equiv}
is an equivalence relation
\item
\tcode{comp}
induces a well-defined relation on the equivalence
classes determined by
\tcode{equiv}
\item
The induced relation is a strict total ordering.
\exitnote
\end{itemize}
\end{itemize}
}
\end{itemdescr}
\end{addedblock}
